# 实验与方法论改进方案

> **目标**: 显著提高测试深度和覆盖率，提升论文的学术价值和贡献度  
> **时间线**: 论文明年提交，有充足时间进行深度改进

---

## 📊 当前状态分析

### ✅ 已完成的工作

- **AST-based mutations**: 175个测试用例
- **源代码插桩**: 已完成异常日志功能
- **基础fuzzing框架**: 完整的测试基础设施

### ❌ 当前局限性

| 指标 | 当前值 | 目标 |
|------|--------|------|
| 代码行覆盖率 | ~30-40% | >70% |
| 异常路径覆盖率 | ~0% | >50% |
| 边界条件覆盖率 | ~0% | >30% |
| 测试用例数量 | 175 | 10,000+ |

### 🔍 问题分析

1. **AST mutations 都是"合法的"**
   - 语法正确 ✅
   - 类型正确 ✅
   - 只改变语义 ✅
   - **结果**: 只测试了正常执行路径

2. **未测试的边界条件**（在 `sledgehammer.ML` 中发现11处可能的异常点）
   - `error "No prover is set"` (Line 530)
   - `error "No subgoal!"` (Line 533)
   - `error "No such prover"` (Line 588)
   - `error "preplay failed"` (Line 308)
   - `raise TERM` (Line 79-81)
   - 等等...

3. **覆盖率不足的原因**
   - 我们的mutations不会触发异常路径
   - 没有测试配置层面的错误
   - 没有测试外部prover崩溃情况

---

## 🚀 改进方案总览

| 优先级 | 方案 | 预期收益 | 难度 | 时间 |
|--------|------|----------|------|------|
| ★★★★★ | **A. 破坏性Mutations** | 发现真正Bug | ⭐⭐⭐ | 1-2周 |
| ★★★★☆ | **B. 配置级Fuzzing** | 边界条件测试 | ⭐⭐ | 1周 |
| ★★★★☆ | **C. 代码覆盖率测量** | 量化指标 | ⭐⭐⭐ | 2周 |
| ★★★☆☆ | **D. 外部Prover崩溃测试** | 集成Bug | ⭐⭐⭐⭐ | 2-3周 |
| ★★★☆☆ | **E. Metamorphic Testing** | 方法论创新 | ⭐⭐⭐ | 2周 |
| ★★☆☆☆ | **F. 大规模Fuzzing** | 统计意义 | ⭐⭐ | 持续进行 |

---

## 📋 详细方案

### 方案A: 破坏性Mutations ★★★★★

**目标**: 触发异常路径，发现真正的Bug

#### 新增Mutation类型

1. **语法错误注入**
   ```isabelle
   - 删除关键字: lemma → lema
   - 破坏括号匹配: (A ∧ B → (A ∧ B))
   - 删除分号/引号: "text" → text
   - 错误的结构: theory → theoryy
   ```

2. **类型错误注入**
   ```isabelle
   - 用 string 替换 nat: 1 → "1"
   - 用 bool 替换 int: 5 → True
   - 创建类型不匹配: "text" + 1
   - 错误的函数应用: map string [1,2,3]
   ```

3. **引用错误**
   ```isabelle
   - 使用不存在的定理名: apply (rule nonexistent_theorem)
   - 使用不存在的函数名: nonexistent_function x
   - 错误的 imports: imports NonExistent_Theory
   - 错误的类型名称: non_existent_type
   ```

4. **无限递归/循环**
   ```isabelle
   - 自引用定义: lemma x: "x = x + 1"
   - 循环引用: lemma A: "B" and B: "A"
   - 无限循环表达式: fix x where "x = x"
   ```

#### 实现方法

```python
# 在 ast_mutator.py 中添加新的mutation operators:

class DestructiveMutator:
    def inject_syntax_error(self, content):
        """注入语法错误"""
        # 随机删除关键字
        # 破坏括号匹配
        # 删除引号等
        pass
    
    def inject_type_error(self, ast):
        """注入类型错误"""
        # 替换类型
        # 创建类型不匹配
        pass
    
    def inject_reference_error(self, ast):
        """注入引用错误"""
        # 替换为不存在的名称
        pass
```

#### 预期结果

- ✅ 触发 catch 块
- ✅ 日志记录到 `/tmp/sledgehammer_hidden_errors.log`
- ✅ 可能发现真正的崩溃/异常
- ✅ 测试覆盖率提升到 50%+

#### 实现难度

⭐⭐⭐ - 需要修改 `ast_mutator.py`，添加新的mutation operators

---

### 方案B: 配置级Fuzzing ★★★★☆

**目标**: 测试 Sledgehammer 的配置健壮性

#### Fuzzing 目标

1. **证明器配置**
   ```python
   test_cases = [
       {"provers": ["nonexistent_prover"]},  # 不存在的prover
       {"provers": []},                      # 空列表
       {"provers": ["e", "cvc5", "z3", "vampire", "all_at_once"]},  # 全部
       {"provers": ["invalid_name_12345"]},  # 随机字符串
   ]
   ```

2. **超时设置**
   ```python
   timeout_cases = [
       0,           # 零超时
       0.001,       # 极短超时
       0.1,         # 很短
       999999,      # 极长超时
       -1,          # 负值
       "invalid",   # 非数字
   ]
   ```

3. **选项组合**
   ```python
   option_cases = [
       {"max_facts": -1},      # 负值
       {"max_facts": 0},       # 零
       {"max_facts": 100000},  # 极大值
       {"timeout": 0, "max_facts": -1},  # 组合异常
   ]
   ```

4. **环境变量**
   ```python
   env_cases = [
       {"ISABELLE_HOME": ""},           # 删除
       {"PATH": "/nonexistent"},        # 错误的PATH
       # 模拟缺失的prover可执行文件
   ]
   ```

#### 实现方法

```python
# 创建 config_fuzzer.py

class ConfigFuzzer:
    def fuzz_provers(self):
        """Fuzzing prover配置"""
        pass
    
    def fuzz_timeout(self):
        """Fuzzing timeout设置"""
        pass
    
    def fuzz_options(self):
        """Fuzzing各种选项"""
        pass
    
    def run_config_fuzzing(self):
        """运行配置级fuzzing"""
        # 对每个配置组合运行测试
        pass
```

#### 预期结果

- ✅ 触发 "No prover is set"
- ✅ 触发 "No such prover"
- ✅ 发现配置验证漏洞
- ✅ 边界条件覆盖率提升到 30%+

#### 实现难度

⭐⭐ - 相对简单，主要是参数组合测试

---

### 方案C: 代码覆盖率测量 ★★★★☆

**目标**: 量化测试覆盖率

#### 方法

1. **在 Isabelle ML 源代码中添加覆盖率计数器**
   ```ml
   (* 覆盖率计数器 *)
   val coverage_log = Path.explode "/tmp/sledgehammer_coverage.log"
   
   fun log_function_call function_name =
     let
       val timestamp = Date.toString (Date.fromTimeLocal (Time.now ()))
       val log_msg = timestamp ^ " | FUNCTION: " ^ function_name ^ "\n"
     in
       File.append coverage_log log_msg
     end
   
   (* 在每个关键函数入口添加 *)
   fun launch_prover ... =
     (log_function_call "launch_prover";
      ...)
   ```

2. **分支覆盖率**
   ```ml
   fun log_branch branch_name condition =
     let
       val result = if condition then "TAKEN" else "NOT_TAKEN"
       val log_msg = branch_name ^ ": " ^ result ^ "\n"
     in
       File.append coverage_log log_msg
     end
   ```

3. **使用 Poly/ML 的 profiling 功能**（可选）
   ```ml
   PolyML.Profiling.profileOn ();
   (* 运行测试 *)
   PolyML.Profiling.profileOff ();
   PolyML.Profiling.printProfile ();
   ```

#### 输出格式

```
COVERAGE REPORT
===============

Functions called: 45/164 (27.4%)
Branches taken: 23/89 (25.8%)
Exceptions caught: 0/11 (0.0%)

Uncovered functions:
  - error_handler
  - invalid_prover_check
  - resource_limit_handler
  ...

Uncovered branches:
  - catch block (line 368)
  - timeout handler
  ...
```

#### 预期结果

- ✅ 量化的覆盖率指标
- ✅ 识别未测试的代码路径
- ✅ 指导后续测试用例设计
- ✅ 论文中可以展示 "Coverage: 75%" 这样的数据

#### 实现难度

⭐⭐⭐ - 需要大量源代码修改，但我们已经有了插桩的经验

---

### 方案D: 外部Prover崩溃测试 ★★★☆☆

**目标**: 测试 Sledgehammer 处理外部 prover 故障的能力

#### 方法

1. **创建"假"prover**
   ```bash
   #!/bin/bash
   # fake_prover.sh - 模拟各种prover故障
   
   case $((RANDOM % 5)) in
     0)
       echo "Fatal error: segmentation fault" >&2
       exit 1  # 崩溃
       ;;
     1)
       echo "Running..." >&2
       sleep 1000  # 挂起（需要timeout处理）
       ;;
     2)
       echo "garbage output {{{{{{}}}}}"  # 垃圾输出
       exit 0
       ;;
     3)
       kill -9 $$  # 自杀（SIGKILL）
       ;;
     4)
       # 正常输出（对照）
       echo "Proof found"
       exit 0
       ;;
   esac
   ```

2. **替换真实 prover**
   ```python
   # 在测试环境中
   original_eprover = shutil.which("eprover")
   fake_prover_path = "/tmp/fake_eprover.sh"
   # 创建软链接或替换
   ```

3. **运行测试**
   - 使用正常的fuzzing campaign
   - 观察Sledgehammer如何处理prover故障
   - 检查是否有未处理的崩溃

#### 预期结果

- ✅ 测试 Sledgehammer 的错误恢复能力
- ✅ 可能发现未处理的崩溃情况
- ✅ 验证超时处理是否正确
- ✅ 发现资源清理问题

#### 实现难度

⭐⭐⭐⭐ - 需要修改系统配置，可能需要root权限

---

### 方案E: Metamorphic Testing ★★★☆☆

**目标**: 利用数学性质检测Bug（方法论创新）

#### Metamorphic Relations

1. **双重否定不变性**
   ```
   Sledgehammer(P) ≈ Sledgehammer(~~P)
   ```
   如果 P 可证明，那么 ~~P 也应该可证明，结果应该一致。

2. **交换律**
   ```
   Sledgehammer(A ∧ B) ≈ Sledgehammer(B ∧ A)
   Sledgehammer(A ∨ B) ≈ Sledgehammer(B ∨ A)
   ```

3. **结合律**
   ```
   Sledgehammer((A ∧ B) ∧ C) ≈ Sledgehammer(A ∧ (B ∧ C))
   Sledgehammer((A ∨ B) ∨ C) ≈ Sledgehammer(A ∨ (B ∨ C))
   ```

4. **分配律**
   ```
   Sledgehammer(A ∧ (B ∨ C)) ≈ Sledgehammer((A ∧ B) ∨ (A ∧ C))
   ```

5. **子公式性质**
   ```
   如果 Sledgehammer(P ∧ Q) 成功，
   那么 Sledgehammer(P) 也应该成功（通常）
   ```

6. **De Morgan定律**
   ```
   Sledgehammer(¬(A ∧ B)) ≈ Sledgehammer(¬A ∨ ¬B)
   Sledgehammer(¬(A ∨ B)) ≈ Sledgehammer(¬A ∧ ¬B)
   ```

#### 检测方法

```python
class MetamorphicTester:
    def test_double_negation(self, formula):
        """测试双重否定不变性"""
        original = self.run_sledgehammer(formula)
        negated = self.run_sledgehammer(f"~~{formula}")
        assert self.equivalent(original, negated), "Bug found!"
    
    def test_commutativity(self, formula1, formula2):
        """测试交换律"""
        result1 = self.run_sledgehammer(f"{formula1} ∧ {formula2}")
        result2 = self.run_sledgehammer(f"{formula2} ∧ {formula1}")
        assert self.equivalent(result1, result2), "Bug found!"
```

#### 预期结果

- ✅ 发现语义层面的 Bug
- ✅ 不依赖 oracle（无true/false标签）
- ✅ 方法论创新（很少用于theorem provers）
- ✅ 高学术价值

#### 实现难度

⭐⭐⭐ - 需要设计 metamorphic relations 和等价性判断

---

### 方案F: 大规模Fuzzing ★★☆☆☆

**目标**: 通过大规模测试发现稀有Bug

#### 规模目标

| 指标 | 当前 | 目标 |
|------|------|------|
| 测试用例数 | 175 | 10,000+ |
| 种子理论数 | 10 | 100+ |
| 每个种子的mutations | 15-20 | 100+ |
| 并行进程数 | 1 | 8-16 |

#### 方法

1. **增加种子理论**
   - 从 Isabelle AFP (Archive of Formal Proofs) 提取
   - 使用更复杂的数学定理
   - 包含各种数学领域：分析、代数、拓扑等

2. **增加变异深度**
   - 多层嵌套变异
   - 组合多种变异类型
   - 链式变异（mutate already mutated code）

3. **并行化**
   ```python
   from multiprocessing import Pool
   
   def run_parallel_fuzzing(seed_theories, n_workers=8):
       with Pool(n_workers) as pool:
           results = pool.map(mutate_and_test, seed_theories)
       return results
   ```

4. **分布式测试**（可选）
   - 使用多台机器
   - 使用云服务（AWS/GCP）
   - 使用集群计算

#### 预期结果

- ✅ 统计显著性（10,000+ 测试用例）
- ✅ 可能发现稀有边界条件
- ✅ 更强的"无Bug"结论（如果确实没找到）
- ✅ 可以分析Bug发现率（如每10,000个case发现1个）

#### 实现难度

⭐⭐ - 主要是资源问题（时间、计算资源）

---

## 📅 实施时间表

### 第一阶段 (1-2周) - 快速改进

- ✅ **已完成**: 源代码插桩
- → **方案B**: 配置级Fuzzing (简单有效，快速看到结果)
- → **方案A**: 破坏性Mutations (核心改进，最可能发现Bug)

**预期成果**:
- 边界条件覆盖率: 0% → 30%
- 可能发现1-2个真正的Bug
- 异常路径覆盖率: 0% → 20%

### 第二阶段 (2-4周) - 深度改进

- → **方案C**: 代码覆盖率测量 (量化指标，指导后续工作)
- → **方案E**: Metamorphic Testing (方法论创新，学术价值高)

**预期成果**:
- 代码覆盖率: 30-40% → 60-70%
- 新的测试方法论
- 量化数据支撑论文

### 第三阶段 (长期, 1-2月) - 大规模验证

- → **方案D**: 外部Prover崩溃测试 (需要更多系统知识)
- → **方案F**: 大规模Fuzzing (持续进行)

**预期成果**:
- 10,000+ 测试用例
- 全面的系统健壮性验证
- 统计显著的结果

---

## 🎯 预期论文贡献提升

### 当前贡献

- AST-based mutations (基础fuzzing)
- 源代码插桩验证 (进阶分析)
- 175个测试用例

### 改进后的贡献

#### 1. 多层次测试方法论

- **语法层**: 破坏性mutations
- **配置层**: 参数fuzzing  
- **语义层**: metamorphic testing
- **集成层**: prover崩溃测试

#### 2. 量化覆盖率指标

- 代码行覆盖率: XX%
- 分支覆盖率: XX%
- 异常路径覆盖率: XX%
- 边界条件覆盖率: XX%

#### 3. 深度源代码分析

- 插桩测试验证
- 崩溃模拟测试
- 边界条件触发
- 异常路径分析

#### 4. 大规模验证

- 10,000+ test cases
- 统计显著性分析
- 可重复性验证
- 长期运行稳定性

---

## 📈 论文质量提升预期

| 方面 | 当前 | 改进后 |
|------|------|--------|
| **方法论深度** | 基础 | 多层次、创新 |
| **实验规模** | 小规模 | 大规模 + 统计 |
| **技术深度** | 表面 | 源代码级别 |
| **学术价值** | BSc标准 | 研究级别 |
| **可重复性** | 一般 | 优秀 |
| **覆盖完整性** | 30-40% | 60-70%+ |

---

## 💡 实施建议

### 优先级排序

1. **立即开始**: 方案B (配置级Fuzzing) - 简单快速
2. **核心工作**: 方案A (破坏性Mutations) - 最可能发现Bug
3. **量化工作**: 方案C (覆盖率测量) - 提供数据支撑
4. **创新工作**: 方案E (Metamorphic Testing) - 方法论价值
5. **扩展工作**: 方案D + F - 全面验证

### 风险与挑战

1. **时间投入**: 全部实施需要2-3个月
2. **技术难度**: 某些方案需要深入理解Isabelle内部
3. **资源需求**: 大规模fuzzing需要计算资源
4. **维护成本**: 增加的代码需要维护

### 建议

- **灵活调整**: 根据时间和资源调整方案
- **逐步迭代**: 不要一次做太多，逐步改进
- **记录过程**: 记录每个方案的实施过程和结果
- **及时评估**: 定期评估哪个方案最有价值

---

## 📝 总结

通过实施这些改进方案，论文将从 **"基础的BSc项目"** 提升到 **"有深度的研究贡献"**。

核心改进点：
1. ✅ 更全面的测试覆盖
2. ✅ 量化的评估指标
3. ✅ 创新的测试方法论
4. ✅ 大规模验证数据

这将使论文在学术界更有说服力，也展示了深入的技术能力和研究方法论。

---

**文档版本**: 1.0  
**创建日期**: 2025-11-27  
**最后更新**: 2025-11-27

