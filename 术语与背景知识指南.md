# 项目术语与背景知识学习指南
## 针对 Python/Java/C++ 背景的初学者

---

## 🎯 **第一阶段：核心概念（Week 1必须掌握）**

### 1. **定理证明器基础 (Theorem Provers)**

#### **什么是定理证明器 (Theorem Prover/Proof Assistant)?**
```
类比：像编译器检查代码语法错误，但检查数学证明是否正确

你的代码：int x = 5 + 3;  →  编译器检查：语法OK，类型OK
数学证明：∀x. P(x) → Q(x)  →  定理证明器检查：逻辑OK，推理OK
```

**关键术语**:
- **Isabelle/HOL**: 
  - 你项目中要测试的"受害者"
  - 一个交互式定理证明器 (Interactive Theorem Prover, ITP)
  - HOL = Higher-Order Logic (高阶逻辑)
  
- **ATP (Automated Theorem Prover)**:
  - 自动定理证明器，如 E, Vampire
  - 类比：全自动推理引擎
  
- **SMT Solver (Satisfiability Modulo Theories)**:
  - 可满足性模理论求解器，如 Z3, cvc5
  - 类比：能够处理特定理论（算术、集合等）的SAT求解器

#### **为什么需要多个prover?**
```
类比：你的代码用g++编译 → 用clang也试试 → 交叉验证

定理证明：Isabelle验证 → Z3验证 → cvc5验证 → 交叉验证可靠性
```

---

### 2. **Sledgehammer (你的主要测试目标)**

#### **Sledgehammer是什么?**
```
类比：IDE的"自动补全建议"，但针对数学证明

你在Isabelle中写：需要证明某个定理
Sledgehammer自动：
  1. 将问题翻译成外部prover能理解的格式
  2. 调用多个prover（Z3, cvc5等）尝试自动证明
  3. 如果成功，尝试在Isabelle中重构这个证明
```

**关键流程 (你的PPT中有)**:
```
HOL goal → Fact selection → Encoding → External prover → Parsing → Reconstruction
```
类比：Java源码 → 编译 → JVM字节码 → JVM执行 → 结果解析 → 返回

#### **关键术语**:
- **Proof reconstruction (证明重构)**:
  - 外部prover说"找到了证明"
  - 但需要在Isabelle内部重新验证这个证明
  - **你项目中的主要bug来源**！

- **Encoding (编码/翻译)**:
  - 将Isabelle的HOL逻辑转换成TPTP或SMT-LIB格式
  - 类比：将Python代码转换成JSON格式
  
- **lam_trans (λ-abstraction translation)**:
  - 如何处理高阶函数/λ表达式的编码策略
  - 类比：Java中的lambda表达式如何序列化
  
- **type_enc (type encoding)**:
  - 如何处理类型信息的编码策略
  - 类比：C++的模板如何转换成C代码

---

### 3. **格式和协议**

#### **TPTP (Thousands of Problems for Theorem Provers)**
```
类比：就像HTML是网页的标准格式，TPTP是定理证明的标准输入格式

例子：
fof(axiom1, axiom, ![X, Y]: (p(X) => p(Y))).
fof(conjecture1, conjecture, ![X]: p(X)).
```

#### **SMT-LIB 2.0**
```
类比：就像JSON是数据交换格式，SMT-LIB是SMT求解器的输入格式

例子（S-expression风格）：
(set-logic QF_LIA)
(declare-fun x () Int)
(assert (> x 0))
(check-sat)
```
**你需要了解的语法**:
- `set-logic`: 指定使用的理论（算术、集合等）
- `declare-fun`: 声明函数/变量
- `assert`: 添加约束/假设
- `check-sat`: 检查可满足性（返回 sat/unsat/unknown）

---

### 4. **Fuzzing相关（你学过C++，应该听过但可能不深入）**

#### **Fuzzing (模糊测试)**
```
类比：你写了个计算器程序，fuzzing就是自动生成大量随机输入来测试

传统测试：test_addition(2, 3) → 期待 5
Fuzzing：自动生成 random_input_1, random_input_2... 看程序是否崩溃
```

**关键概念**:
- **Mutation-based fuzzing (基于变异的模糊测试)**:
  - 从已有的有效输入开始（seed）
  - 随机修改这些输入（mutate）
  - 生成新的测试用例
  
- **Structure-aware mutation (结构感知变异)**:
  - 不是随机改字节，而是理解输入的结构
  - 类比：知道这是JSON，就不会破坏JSON语法
  
- **Coverage-guided fuzzing (覆盖率引导)**:
  - 追踪哪些代码路径被执行过
  - 优先生成能探索新路径的输入
  - 你项目中：因为PolyML难以instrument，用代理指标

#### **AFL/LibFuzzer**
```
AFL (American Fuzzy Lop): 
- C/C++项目最流行的fuzzing工具
- 你项目要求的"可以基于AFL扩展"

LibFuzzer:
- LLVM的一部分
- 与AFL类似但集成在编译器中
```

---

### 5. **Oracle（测试预言）**

```
类比：单元测试中的 assert

传统测试：assert(calc(2,3) == 5)
你的项目：需要检测多种异常行为
```

**你的三种Oracle**:

1. **Crash/Hang Oracle**:
   - 程序崩溃或无限循环
   - 类比：`assert(program_does_not_crash(input))`

2. **Differential Oracle (差异测试)**:
   - 相同输入，不同工具给出不同结果 → bug！
   - 类比：同一个JSON文件，Python和Java的parser解析结果不同
   - **注意**：只把 SAT vs UNSAT 当作bug，unknown不算

3. **Reconstruction Oracle**:
   - 外部prover说"找到了证明"
   - 但Isabelle无法重构 → bug！
   - **这是你项目的核心贡献**

---

## 🎯 **第二阶段：Isabelle/HOL 专用概念（Week 2-3学习）**

### 1. **HOL (Higher-Order Logic)**

#### **高阶逻辑 vs 一阶逻辑**
```
一阶逻辑 (First-Order Logic):
- 只能量化变量：∀x. P(x)
- 类比：只能操作数据，不能操作函数

高阶逻辑 (Higher-Order Logic):
- 可以量化函数：∀f. P(f)
- 类比：函数可以作为参数传递（就像Python的first-class functions）

例子：
Isabelle中：函数可以返回函数
fun add :: "int => int => int" where
  "add x y = x + y"

这在普通的"程序语言"中很正常，但在逻辑系统中，高阶逻辑更强大但也更复杂。
```

#### **类型系统**
```
Isabelle的类型系统类似Haskell或OCaml（如果你没学过）：

基本类型：int, bool, nat (自然数)
函数类型：int => int  (从int到int的函数)
类型类：'a  (泛型，类似Java的<T>)
```

---

### 2. **Isabelle的架构组件**

#### **PolyML**
```
PolyML是Isabelle的底层实现语言（类似JVM之于Java）
- 你需要了解：它很难做代码覆盖率
- 你不需要：精通PolyML/ML编程（除非深入Isabelle内部）
```

#### **AFP (Archive of Formal Proofs)**
```
类比：GitHub上的开源代码库，但是存放数学证明的

你从中提取"种子输入"（seed problems）：
- 像从真实项目中提取测试用例
- 证明各种数学定理的Isabelle代码库
```

#### **Mirabelle (你已经不用了，但知道即可)**
```
Isabelle的内部测试工具
- 你用Sledgehammer CLI替代它
- 了解：它存在，但可能文档不足，所以不用
```

---

### 3. **证明重构的机制**

#### **Metis**
```
Isabelle内部的自动定理证明器
- 用于重构外部prover找到的证明
- 类比：将"外部编译器的输出"翻译回"本地的中间表示"
```

#### **SMT Replay**
```
另一种重构方式，针对SMT求解器的证明
- Z3可以输出proof object
- Isabelle尝试重放（replay）这个证明
```

---

## 🎯 **第三阶段：技术细节（Week 4-6深入）**

### 1. **编码策略参数**

#### **lam_trans (Lambda Translation)**
```
HOL中的高阶函数如何转换成TPTP/SMT-LIB：

选项包括：
- combinator: 使用组合子 (如SKI组合子)
- lifting: 提升（lifting）技术
- 等等

类比：Python的装饰器如何序列化到JSON
```

#### **type_enc (Type Encoding)**
```
如何处理类型信息：

选项包括：
- monomorphize: 单态化（类似C++模板实例化）
- polymorphic: 保留多态
- 等等

类比：C++的模板特化策略
```

**为什么重要？**：
- 不同的encoding可能触发不同的bug
- 你的fuzzer需要系统地测试这些组合

---

### 2. **语法树和解析**

#### **AST (Abstract Syntax Tree)**
```
你已经知道（从编译器课程）：
源代码 → 词法分析 → 语法分析 → AST → 语义分析 → 代码生成

你的项目：
SMT-LIB文件 → 解析 → AST → 变异 → 重新序列化 → 新文件
```

#### **S-expression**
```
SMT-LIB使用S-expression格式（类似Lisp）：

(+ (* 2 x) 3)  // 表示 2x + 3

解析时注意：
- 括号匹配
- 操作符数量匹配
- 类型一致性
```

---

### 3. **Prover的输出格式**

#### **SAT/UNSAT/UNKNOWN**
```
SAT (Satisfiable): 存在满足条件的解
UNSAT (Unsatisfiable): 不存在解（矛盾）
UNKNOWN: 无法确定（超时或不可判定）

类比：
SAT: "这个程序有bug"（找到了反例）
UNSAT: "这个程序是正确的"（证明了）
UNKNOWN: "不知道，太复杂了"
```

#### **Proof Object**
```
Prover返回"我找到了证明"时，可能包含：
- 证明步骤序列
- 使用的公理和引理
- Isabelle需要这个来重构
```

---

## 🎯 **第四阶段：评估和度量（Week 7-9）**

### 1. **覆盖率概念（你项目中是代理）**

#### **代码覆盖率 (Code Coverage)**
```
传统：有多少%的代码行被执行了

你的项目：PolyML难以instrument，用代理指标：
- 触发了多少种不同的异常类型
- 覆盖了多少种encoding参数组合
- 测试了多少种prover输出格式
```

#### **路径覆盖率 (Path Coverage)**
```
你项目中的"接口路径"：
- 不同的编码路径（HOL→TPTP vs HOL→SMT-LIB）
- 不同的prover调用路径（Z3 vs cvc5 vs E）
- 不同的重构路径（Metis vs SMT replay）
```

---

### 2. **统计和度量**

#### **Time-to-First-Bug (TTFB)**
```
第一次发现bug的时间
- 评估fuzzer的效率
- 类比：单元测试的第一次失败
```

#### **Bugs per Hour**
```
每小时发现的bug数量
- 评估fuzzer的吞吐量
- 类比：代码审查的效率
```

#### **Minimization (最小化)**
```
发现bug后，缩小到最小的能触发bug的输入
- 使用Delta Debugging算法
- 类比：bug报告中的"最小可重现示例"
```

---

## 📚 **学习资源推荐**

### **入门级（立即开始）**

1. **Isabelle/HOL官方教程**:
   - https://isabelle.in.tum.de/documentation.html
   - **重点**: "Programming and Proving in Isabelle/HOL"
   - **你只需要**: 了解基本概念，不需要成为专家

2. **SMT-LIB教程**:
   - http://smtlib.cs.uiowa.edu/
   - **重点**: 能看懂SMT-LIB文件格式即可
   - **实践**: 尝试手动写几个简单的SMT-LIB文件

3. **Sledgehammer论文**:
   - Blanchette et al. "Hammering Away"
   - **重点**: 理解工作流程，不是细节实现

### **中级（Week 2-3）**

4. **Fuzzing基础**:
   - AFL官方文档: https://github.com/google/AFL
   - **重点**: 理解mutation和coverage-guided的原理

5. **TPTP格式**:
   - http://www.tptp.org/TPTP/TR/TPTPTR.shtml
   - **重点**: 语法规则，不需要完全掌握

6. **Differential Testing**:
   - McKeeman "Differential Testing for Software"
   - **重点**: 为什么SAT vs UNSAT是bug，unknown不是

### **高级（Week 4+，按需）**

7. **HOL类型系统**:
   - 只有深入Isabelle内部时才需要

8. **证明重构技术**:
   - 只有实现reconstruction oracle的细节时才需要

---

## ⚠️ **你不需要学什么**

```
❌ 不需要成为Isabelle专家
   → 只需要理解它如何与外部prover交互

❌ 不需要精通ML/OCaml
   → 你的代码主要是Python

❌ 不需要完全理解HOL的语义
   → 只需要知道编码会出问题

❌ 不需要成为SMT/ATP理论专家
   → 只需要知道它们的输入输出格式

❌ 不需要证明数学定理
   → 只需要测试证明系统本身
```

---

## 🎯 **快速检查清单**

### **Week 1结束时，你应该能回答**:

- [ ] Sledgehammer是什么？它的输入输出是什么？
- [ ] 什么是proof reconstruction？为什么会失败？
- [ ] SMT-LIB格式的基本语法（能看懂简单文件）
- [ ] 什么是differential testing？为什么SAT vs UNSAT是bug？
- [ ] 你的fuzzer的基本工作流程（seed → mutate → test → oracle）

### **Week 2-3结束时，你应该能**:

- [ ] 手动运行一次Sledgehammer并导出SMT-LIB文件
- [ ] 理解encoding参数（lam_trans, type_enc）的作用
- [ ] 解析SMT-LIB文件到AST（用Python库）
- [ ] 实现简单的mutation（token级别）

### **Week 4+结束时，你应该能**:

- [ ] 理解你发现的bug的原因（至少从现象上）
- [ ] 解释为什么你的fuzzer比baseline好
- [ ] 理解评估指标的局限性（代理指标）

---

## 💡 **类比总结（帮助你记忆）**

```
Isabelle/HOL     = 你的IDE（开发环境）
Sledgehammer     = IDE的"自动完成"插件
外部Prover (Z3)  = 外部代码检查工具（如clang-tidy）
TPTP/SMT-LIB     = JSON/XML（数据交换格式）
Proof            = 单元测试（验证正确性）
Reconstruction   = 反编译（将机器码转回源码）
Encoding         = 序列化（对象转JSON）
Fuzzing          = 压力测试（随机输入）
Oracle           = assert（检查条件）
```

---

**记住：你不必成为所有这些领域的专家，只需要理解足够的内容来完成你的项目！** 🚀

 